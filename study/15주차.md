## 15주차 과제
> 자바의 람다식에 대해 학습

## 목차
- [람다식](#람다식)
- [람다식 사용법](#람다식-사용법)
- [함수형 인터페이스](#함수형-인터페이스)
- [Variable Capture](#variable-capture)
- [메소드, 생성자 레퍼런스](#메소드-생성자-레퍼런스)

## 람다식 // 컴파일 후 바이트코드?
자바는 객체 지향 언어이지만, 병렬 처리와 이벤트 지향 프로그래밍에 적합한 함수형 프로그래밍이 부각됨에 따라 **함수형 프로그래밍 지원을 위해 람다식 도입**

람다식은 익명 함수를 생성하기 위한 식

자바가 람다식을 수용한 이유
- 코드의 간결화
- 컬렉션 요소를 필터링하거나 매핑하여 원하는 결과를 쉽게 집계 가능

### 사용 예시
```JAVA
// 익명함수
Runnable runnable = new Runnable() {
  @Override
  public void run() { . . . }
};
```
```JAVA
// 람다식
Runnable runnable = () -> { . . . };
```
- ```(매개변수) -> {실행코드}``` 형식
- 런타임 시 **인터페이스의 익명 구현 객체**로 생성

:arrow_double_up:[Top](#15주차-과제)

<br />

## 람다식 사용법
### 람다식 작성 방법
```JAVA
(타입 매개변수, ...) -> { 실행문; ... }
```
```JAVA
() -> { 실행문; }
```
- ```(타입 매개변수)```는 오른쪽 중괄호 {} 블록을 실행하기 위해 필요한 값을 제공하는 역할
- 전달할 매개변수가 없다면 소괄호만 입력

<br />

### 사용 예시
```JAVA
(int a) -> { System.out.println(a); } // 기본적인 람다식
```
```JAVA
(a) -> { System.out.println(a); }     // 매개 타입은 런타임 시 자동 인식 가능하므로 일반적으로 생략해서 사용
```
```JAVA
a -> System.out.println(a)            // 한 개의 매개변수만 있다면 소괄호 생략 가능, 한 줄의 실행문만 있다면 중괄호 생략 가능
```
```JAVA
(x, y) -> { return x + y; }           // 실행 후 리턴값이 필요하다면 return문 사용 가능
```
```JAVA
(x, y) -> x + y                       // 실행부에 return문만 있을 경우
```

<br />

### 클래스 멤버와 로컬 변수의 사용
#### 클래스 멤버
람다식의 실행부에는 클래스의 멤버인 필드와 메소드를 제약 없이 사용 가능

주의할 점은 익명 객체 내부의 ```this```는 익명 객체의 참조이지만, **람다식의 ```this```는 익명 객체가 아닌, 람다식을 실행한 객체의 참조**

```JAVA
public interface MyInterface {
  void method();
}
```
```JAVA
public class UsingThis {
  public int outter = 10;

  class Inner {
    int inner = 20;

    void usingThisMethod() {
      // 람다식으로 메소드 구현
      MyInterface mi = () -> {
        // 바깥 객체의 참조를 얻기 위해 클래스명.this 사용
        System.out.println(UsingThis.this.outter);

        // 람다식은 람다식을 실행한 객체를 참조
        System.out.println(this.inner);
      };

      mi.method();
    }
  }
}
```
실행 코드
```JAVA
public class UsingThisEx {
  public static void main(String[] args) {
    UsingThis usingThis = new UsingThis();
    UsingThis.Inner inner = usingThis.new Inner();
    inner.method();
  }
}
```

<br />

#### 로컬 변수
메소드 매개 변수와 메소드 내 정의된 변수는 람다식에서 변경하려면 ```final```이어야만 가능

이는 익명 객체 생성 시에도 마찬가지이며, 이유는 **메소드 내에서 생성된 익명 객체/람다식은 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용 가능**하지만, **매개 변수나 로컬 변수는 메소드 실행 종료 시 스택 메모리에서 사라지기 때문**에 문제 발생

따라서 로컬 변수는 람다식에서 읽는 것만 가능하고 값 변경은 불가능

:arrow_double_up:[Top](#15주차-과제)

<br />

## 함수형 인터페이스 // 사칙연산 예시 코드??
### 타겟 타입
```JAVA
인터페이스 변수 = 람다식;
```
자바는 메소드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하며, 이에 따라 **람다식은 단순히 메소드를 선언하는 것이 아니라 메소드를 가진 객체를 생성**

람다식은 인터페이스 변수에 대입하여 사용하며, **인터페이스의 익명 구현 객체를 생성**하는 것
- 인터페이스가 직접 객체화할 수 없는 것을 람다식이 해줌

이 때, **람다식이 대입될 인터페이스를 람다식의 타겟 타입**이라고 지칭하는데, 모든 인터페이스가 람다식의 타겟 타입이 될 수는 없으며 **함수형 인터페이스만 타겟 타입**이 가능

<br />

### 함수형 인터페이스 @FunctionalInterface
**하나의 추상 메소드가 선언된 인터페이스**

람다식은 하나의 메소드만 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 타겟 타입 불가능

**```@FunctionalInterface```**
- 함수형 인터페이스 작성 시 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체크하게 하는 애노테이션
- 애노테이션을 추가하지 않아도 추상 메소드가 한 개라면 함수형 인터페이스

```JAVA
@FunctionalInterface
public interface MyFunctionalInterface {
  void method();
  void otherMethod(); // 컴파일 에러
}
```

<br />

### 사용 예시
#### 매개변수와 리턴값이 없는 람다식
```JAVA
// 정의
@FunctionalInterface
public interface MyFunctionalInterface {
  void method();
}
```
```JAVA
// 사용
MyFunctionalInterface fi = () -> { ... }
fi.method();
```

#### 매개변수가 있는 람다식
```JAVA
// 정의
@FunctionalInterface
public interface MyFunctionalInterface {
  void method(int x);
}
```
```JAVA
// 사용
MyFunctionalInterface fi = x -> { ... } // 꼭 x 아니어도 됨
fi.method(10);
```

#### 리턴값 있는 람다식
```JAVA
// 정의
@FunctionalInterface
public interface MyFunctionalInterface {
  int method(int x, int y);
}
```
```JAVA
// 사용
MyFunctionalInterface fi = (x, y) -> { ... }
int result = fi.method(5, 10);
```

<br />

### 표준 API의 함수형 인터페이스
자바 8부터 ```java.util.function``` 패키지에서 표준 API로 제공하는 함수형 인터페이스

|종류|추상 메소드 특징|
|----|----|
|Consumer|매개값 有 / 리턴값 無|
|Supplier|매개값 無 / 리턴값 有|
|Function|매개값 有 / 리턴값 有<br />주로 매개값을 리턴값으로 매핑(타입변환)|
|Operator|매개값 有 / 리턴값 有<br />주로 매개값의 연산 결과 리턴|
|Predicate|매개값 有 / 리턴 타입 boolean<br />매개값을 조사해서 true/false 리턴|

표준 함수형 인터페이스의 목적은 메소드 또는 생성자의 매개 타입으로 사용되어 람다식을 대입하기 위함

<br />

#### Consumer 인터페이스
매개값을 받아서 ```accept()``` 메소드에서 처리하는 인터페이스

![consumer](../image/Consumer.png)

```JAVA
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

- 매개 변수의 타입과 수에 따른 Consumer 종류
  |인터페이스 명|추상 메소드|설명|
  |---|---|---|
  |Consumer\<T\>|void accept(T t)|객체 T를 받아 소비|
  |BiConsumer<T, U>|void accept(T t, U u)|객체 T와 U를 받아 소비|
  |DoubleConsumer|void accept(double value)|double 값을 받아 소비|
  |IntConsumer|void accept(int value)|int 값을 받아 소비|
  |LongConsumer|void accept(long value)|long 값을 받아 소비|
  |ObjDoubleConsumer\<T\>|void accept(T t, double value)|객체 T와 double 값을 받아 소비|
  |ObjIntConsumer\<T\>|void accept(T t, int value)|객체 T와 int 값을 받아 소비|
  |ObjLongConsumer\<T\>|void accept(T t, long value)|객체 T와 long 값을 받아 소비|


**사용 예시**
```JAVA
Consumer<String> consumer = t -> System.out.println(t);
consumer.accept("java");

BiConsumer<String, Integer> biConsumer = (t, u) -> System.out.println(t + u);
biConsumer.accept("java", "8");

DoubleConsumer doubleConsumer = d -> System.out.println(d);
doubleConsumer.accept(8.0);

ObjIntConsumer<String> objConsumer = (t, i) -> System.out.println(t + i);
objConsumer.accept("JAVA", 8);
```

<br />

#### Supplier 인터페이스
.```getXXX()``` 메소드 실행 후 호출한 곳으로 결과 데이터를 리턴(공급)

![supplier](../image/Supplier.png)

```JAVA
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

- Supplier 종류
  |인터페이스 명|추상 메소드|
  |---|---|
  |Supplier\<T\>|T get()|
  |BooleanSupplier|boolean getAsBoolean()|
  |DoubleSupplier|double getAsDouble()|
  |IntSupplier|int getAsInt()|
  |LongSupplier|long getAsLong()|


**사용 예시**
```JAVA
IntSupplier intSupplier = () -> {
  int num = (int) (Math.random() * 6) + 1;
  return num;
}
```

<br />

#### Function 인터페이스
매개값과 리턴값이 있는 ```applyXXX()``` 메소드를 실행하여, 매개값을 리턴값으로 매핑(타입 변환)

![function](../image/Function.png)

- 매개 변수 타입과 리턴 타입에 따른 Function 종류
  |인터페이스 명|추상 메소드|설명|
  |---|---|---|
  |Function<T, R>|R apply(T t)|객체 T를 R로 매핑|
  |BiFunction<T, U, R>|R apply(T t, U u)|객체 T, U를 R로 매핑|
  |DoubleFunction<R>|R apply(double value)|double을 객체 R로 매핑|
  |IntFunction<R>|R apply(int value)|int를 객체 R로 매핑|
  |IntToDoubleFunction|double applyAsDouble(int value)|int를 double로 매핑|
  |IntToLongFunction|long applyAsLong(int value)|int를 long으로 매핑|
  |LongToDoubleFunction|double applyAsDouble(long value)|long을 double로 매핑|
  |LongToIntFunction|int applyAsInt(long value)|long을 int로 매핑|
  |ToDoubleBiFunction<T, U>|double applyAsDouble(T t, U u)|객체 T, U를 double로 매핑|
  |ToDoubleFunction<T>|double applyAsDouble(T t)|객체 T를 double로 매핑|
  |ToIntBiFunction<T, U>|int applyAsInt(T t, U u)|객체 T, U를 int로 매핑|
  |ToIntFunction<T, U>|int applyAsInt(T t)|객체 T를 int로 매핑|
  |ToLongBiFunction<T, U>|long applyAsLong(T t, U u)|객체 T, U를 long으로 매핑|
  |ToLongFunction<T>|long applyAsLong(T t)|객체 T를 long으로 매핑|


<br />

#### Operator 인터페이스
![operator](../image/Operator2.png)

<br />

#### Predicate 인터페이스
![predicate](../image/Predicate.png)

<br />

:arrow_double_up:[Top](#15주차-과제)

<br />

## Variable Capture


:arrow_double_up:[Top](#15주차-과제)

<br />

## 메소드, 생성자 레퍼런스


:arrow_double_up:[Top](#15주차-과제)

<br />

### Reference
- 신용권, 『이것이 자바다』, 한빛미디어(2015)
